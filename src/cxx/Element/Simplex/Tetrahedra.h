#pragma once

#include <Eigen/Dense>
#include <Model/ExodusModel.h>
#include <Source/Source.h>
#include <Mesh/Mesh.h>
#include <Element/Element.h>

extern "C" {
#include <Tetrahedra/Autogen/p3_tetrahedra.h>
}


/**
 * Base class of an abstract four node tetrahedra. The reference element is set up as below.
 * 
 *              (v3)
 *                +--
 *                | \----
 *                |   \--\----
 *                |      \--  \----
 *                |         \-     \---  (v1)
 *                |           \--      \--
 *  ^             |              \--/---  \
 *  |             |             /---\-     \
 *  | (t)         |         /---      \--   \
 *  |             |     /---             \-- \
 *  |      (s)    | /---                    \-\
 *  |       /-    +---------------------------\--
 *  |    /--     (v0)                        (v2)
 *  | /--
 *  +-----------------> (r)
 * 
 * Faces are organized like: bottom (r-s), left (s-t), front (r-t), right (r-s-t)
 * More precisely, faces are composed of vertices and ordered
 * 0: 0 1 2
 * 1: 0 3 1
 * 2: 0 2 3
 * 3: 2 1 3
 * Edge ordering
 * (v0,v1)
 * (v1,v2)
 * (v2,v0)
 * (v0,v3)
 * (v3,v1)
 * (v2,v3)
 */

class Tetrahedra: public Element {

 protected:

  /*****************************************************************************
   * STATIC MEMBERS. THESE VARIABLES AND FUNCTIONS SHOULD APPLY TO ALL ELEMENTS.
   *****************************************************************************/

  static int mNumberVertex;
  /** < Num of element vertices. */

  static Eigen::MatrixXd mGradientOperator;
  /** < Derivative of shape function n (col) at pos. m (row) */
  static Eigen::VectorXd mIntegrationWeights;
  /** < Integration weights along epsilon direction. */
  static Eigen::VectorXd mIntegrationCoordinates_r;
  /** < Nodal location directions */
  static Eigen::VectorXd mIntegrationCoordinates_s;  
  static Eigen::VectorXd mIntegrationCoordinates_t;  

  /** r-derivative of Lagrange poly Phi [row: phi_i, col: phi @ nth point]*/
  static Eigen::MatrixXd mGradientPhi_dr;
  /** s-derivative of Lagrange poly Phi [row: phi_i, col: phi @ nth point]*/
  static Eigen::MatrixXd mGradientPhi_ds;
  static Eigen::MatrixXd mGradientPhi_dt;

  /**********************************************************************************
   * OBJECT MEMBERS. THESE VARIABLES AND FUNCTIONS SHOULD APPLY TO SPECIFIC ELEMENTS.
   ***********************************************************************************/

 public:

  /**
   * Factory return the proper element physics based on the command line options.
   * @return Some derived element class.
   */
  static Tetrahedra *factory(Options options);

  /**
   * Constructor.
   * Sets quantities such as number of dofs, among other things, from the options class.
   * @param [in] options Populated options class.
   */
  Tetrahedra(Options options);

  /**
   * Destructor.
   */
  ~Tetrahedra() {};

  /**
   * Returns the gll locations for a given polynomial order.
   * @param [in] order The polynmomial order.
   * @returns tuple of quadrature points (r,s).
   */
  static std::tuple<Eigen::VectorXd, Eigen::VectorXd, Eigen::VectorXd> QuadraturePointsForOrder(const int order);

  /**
   * Returns the quadrature intergration weights for a polynomial order.
   * @param [in] order The polynomial order.
   * @returns Vector of quadrature weights.
   * TODO: Move to autogenerated code.
   */
  static Eigen::VectorXd QuadratureIntegrationWeightForOrder(const int order);

  /**
   * Returns the mapping from the PETSc to Salvus closure.
   * @param [in] order The polynomial order.
   * @param [in] dimension Element dimension.
   * @returns Vector containing the closure mapping (field(closure(i)) = petscField(i))
   */
  Eigen::VectorXi ClosureMapping(const int order, const int dimension,
                                 DM &distributed_mesh);

  void BuildClosureMapping(DM &distributed_mesh);
  
  static Eigen::Vector4d interpolateAtPoint(double r, double s, double t);
  Eigen::MatrixXd interpolateFieldAtPoint(const Eigen::VectorXd &pnt) {
    return Eigen::Matrix<double, -1, -1, 0, -1, -1>();
  }

  void recordField(const Eigen::MatrixXd &u) {};

  // currently not possible
  // /**
  //  * Returns the face mapping from the PETSc to Salvus closure.
  //  * @param [in] order The polynomial order.
  //  * @param [in] dimension Element dimension.
  //  * @returns Vector containing the closure mapping (field(closure(i)) = petscField(i))
  //  */
  // static Eigen::VectorXi FaceClosureMapping(const int order, const int dimension);

  // Attribute gets.

  // virtual Eigen::VectorXi GetFaceClosureMapping() { return mFaceClosureMapping; }

  // virtual Eigen::MatrixXd VtxCrd() { return mVtxCrd; }

  /********************************************************
   ********* Inherited methods from Element 2D ************
   ********************************************************/

  /**
   * Checks whether a given point in realspace (x, z) is within the current element.
   * A simple convex hull algorithm is implemented. Should work as long as the sides of the element are straight
   * lines, but will likely fail for higher order shape functions.
   * @param [in] x X-coordinate in real space.
   * @param [in] z Z-coordinate in real space.
   * @returns True if point is inside, False if not.
   */
  bool mCheckHull(double x, double y, double z);

  /**
   * 2x2 inverse Jacobian matrix at a point (r,s,t).  This method returns an Eigen::Matrix
   * representation of the inverse Jacobian at a particular point.
   * @param [in] eps Epsilon position on the reference element.
   * @param [in] eta Eta position on the reference element.
   * @returns (inverse Jacobian matrix,determinant of that matrix) as a `std::tuple`. Tuples can be
   * "destructured" using a `std::tie`.
   */
  std::tuple<Eigen::Matrix3d, PetscReal> inverseJacobianAtPoint(PetscReal r, PetscReal s, PetscReal t);

  /**
   * Given a point in realspace, determines the equivalent location in the reference element.
   * Since the shape function is linear, the inverse transform is a simple analytic formula.
   * @param [in] x_real X-coordinate in real space.
   * @param [in] y_real Y-coordinate in real space.
   * @param [in] z_real Z-coordinate in real space.
   * @return A Vector (eps, eta) containing the coordinates in the reference element.
   */
  Eigen::Vector3d inverseCoordinateTransform(const double &x_real,
                                             const double &y_real,
                                             const double &z_real);

  /**
   * Attaches a material parameter to the vertices on the current element.
   * Given an exodus model object, we use a kD-tree to find the closest parameter to a vertex. In practice, this
   * closest parameter is often exactly coincident with the vertex, as we use the same exodus model for our mesh
   * as we do for our parameters.
   * @param [in] model An exodus model object.
   * @param [in] parameter_name The name of the field to be added (i.e. velocity, c11).
   * @returns A Vector with 4-entries... one for each Element vertex, in the ordering described above.
   */
  Eigen::Vector4d __attachMaterialProperties(ExodusModel *model,
                                             std::string parameter_name);

  /**
   * Utility function to integrate a field over the element. This could probably be made static, but for now I'm
   * just using it to check some values.
   * @param [in] field The field which to integrate, defined on each of the gll points.
   * @returns The scalar value of the field integrated over the element.
   */
  double integrateField(const Eigen::VectorXd &field);

  /**
   * Setup the auto-generated gradient operator, and stores the result in mGrd.
   */
  void setupGradientOperator();


  /**
   * Queries the passed DM for the vertex coordinates of the specific element. These coordinates are saved
   * in mVertexCoordiantes.
   * @param [in] distributed_mesh PETSc DM object.
   *
   */
  void attachVertexCoordinates(DM &distributed_mesh);

  /**
   * Attach source.
   * Given a vector of abstract source objects, this function will query each for its spatial location. After
   * performing a convex hull test, it will perform a quick inverse problem to determine the position of any sources
   * within each element in reference coordinates. These reference coordinates are then saved in the source object.
   * References to any sources which lie within the element are saved in the mSrc vector.
   * @param [in] sources A vector of all the sources defined for a simulation run.
   */
  void attachSource(std::vector<std::shared_ptr<Source>> sources);

  /**
   * Atttach receiver.
   * Given a vector of abstract receiver objects, this function will query each for its spatial location. After
   * performing a convex hull test, it will perform a quick inverse problem to determine the position of any
   * sources within each element in reference coordiantes. These reference coordinates are then saved in the
   * receiver object. References to any receivers which lie within the element are saved in the mRec vector.
   * @param [in] receivers A vector of all the receivers defined for a simulation run.
   */
  void attachReceiver(std::vector<std::shared_ptr<Receiver>> &receivers);

  /**
   * Simple function to set the (remembered) element number.
   */
  void SetNum(int element_number) { mElmNum = element_number; }

  /**
   * Builds nodal coordinates (x,z) on all mesh degrees of freedom.
   * @param mesh [in] The mesh.
   */
  std::tuple<Eigen::VectorXd, Eigen::VectorXd, Eigen::VectorXd> buildNodalPoints();

  // for testing
  inline int __GetNumIntPts() { return mIntegrationWeights.size(); }
  inline Eigen::VectorXd __GetIntCoordR() { return mIntegrationCoordinates_r; }
  inline Eigen::VectorXd __GetIntCoordS() { return mIntegrationCoordinates_s; }
  inline Eigen::VectorXd __GetIntCoordT() { return mIntegrationCoordinates_t; }

  
};
